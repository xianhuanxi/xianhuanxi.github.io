<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Xitoys.cn - ç”Ÿç‰©æ„Ÿäº¤äº’ç³»ç»Ÿ</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        body, html { width: 100%; height: 100%; overflow: hidden; background: #ff5f8d; }
        #main-container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at 50% 50%, #ff85ad 0%, #ff5f8d 100%); }

        .brand-box {
            position: absolute; top: 8%; left: 0; right: 0; text-align: center;
            z-index: 5; pointer-events: none;
        }
        .brand-box h1 {
            color: white; font-size: 22vw; font-weight: 900; font-style: italic;
            text-shadow: 0 10px 40px rgba(0,0,0,0.4);
            letter-spacing: -3px;
        }

        .bubble-node {
            position: absolute; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center; 
            color: white; font-weight: bold; 
            border: 2px solid rgba(255,255,255,0.6);
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(255,255,255,0.2) 50%, rgba(135,206,250,0.4) 100%);
            box-shadow: inset -10px -10px 30px rgba(255,255,255,0.4), 0 15px 50px rgba(0,0,0,0.3);
            backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
            will-change: transform; transition: transform 0.1s ease-out;
            pointer-events: auto;
        }

        .main-giant {
            background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.95), rgba(255,180,0,0.5) 60%, rgba(255,0,80,0.6) 100%);
            box-shadow: inset -15px -15px 40px rgba(255,255,255,0.5), 0 20px 60px rgba(0,0,0,0.4);
        }

        #interaction-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
    </style>
</head>
<body>

<div id="main-container">
    <div class="brand-box"><h1>Xitoys</h1></div>
    <div id="bubble-canvas-wrap"></div>
    <canvas id="interaction-layer"></canvas>
</div>

<script>
    const canvas = document.getElementById('interaction-layer');
    const ctx = canvas.getContext('2d');
    const wrap = document.getElementById('bubble-canvas-wrap');

    let w, h, bubbles = [], time = 0;
    let dragTarget = null, dragOffset = { x: 0, y: 0 };
    let touchStartTime = 0;

    const config = [
        { name: 'æ¬¢å–œæ•…äº‹', r: 72, url: 'story.html' },
        { name: 'ä¸¤æ€§ç§‘æ™®', r: 82, url: 'science.html' },
        { name: 'è§†é¢‘é¢‘é“', r: 68, url: 'video.html' },
        { name: 'æˆ‘è¦æŠ•èµ„', r: 62, url: 'invest.html' },
        { name: 'ðŸ›’ åœ¨çº¿è´­ç‰©', r: 170, isMain: true, url: 'shop.html' }
    ];

    function init() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
        wrap.innerHTML = '';
        bubbles = [];

        const logoAreaBottom = h * 0.35; // logo åŒºåŸŸåº•éƒ¨ï¼ˆçº¦1/3å±å¹•ï¼‰

        config.forEach((d, i) => {
            const el = document.createElement('div');
            el.className = 'bubble-node' + (d.isMain ? ' main-giant' : '');
            el.style.width = el.style.height = (d.r * 2) + 'px';
            el.innerHTML = `<span style="font-size:\( {d.isMain?32:20}px; text-shadow:0 3px 12px rgba(0,0,0,0.3);"> \){d.name}</span>`;
            wrap.appendChild(el);

            const isMain = d.isMain;
            let x = isMain ? w - d.r * 1.5 : w * (0.1 + Math.random() * 0.8);
            let y = isMain ? h - d.r * 1.5 : logoAreaBottom + Math.random() * (h - logoAreaBottom - d.r * 2);

            bubbles.push({
                el, r: d.r, baseR: d.r,
                x, y,
                vx: 0, vy: 0,
                isMain, url: d.url,
                phase: Math.random() * Math.PI * 2
            });
        });
    }

    function update() {
        time += 0.02;

        bubbles.forEach((b, i) => {
            const breath = Math.sin(time + b.phase) * 0.12;
            b.r = b.baseR * (1 + breath);
            const scale = 1 + breath * 0.8;

            if (!b.isMain && !b.dragging) {
                b.vx += (Math.random() - 0.5) * 0.25;
                b.vy += (Math.random() - 0.5) * 0.25;
                b.vx *= 0.97;
                b.vy *= 0.97;
                b.x += b.vx;
                b.y += b.vy;
            }

            // å¢žå¼ºæ–¥åŠ› + å‘¼å¸åŒæ­¥
            bubbles.forEach((other, j) => {
                if (i === j) return;
                const dx = other.x - b.x;
                const dy = other.y - b.y;
                const dist = Math.hypot(dx, dy);
                if (dist < 1) return;

                const force = (600 - dist) * (0.001 + breath * 0.002);
                const nx = dx / dist;
                const ny = dy / dist;

                if (!b.isMain && !b.dragging) {
                    b.vx -= nx * force;
                    b.vy -= ny * force;
                }
                if (!other.isMain && !other.dragging) {
                    other.vx += nx * force;
                    other.vy += ny * force;
                }

                const minDist = b.r + other.r + 15;
                if (dist < minDist) {
                    const overlap = minDist - dist;
                    const push = overlap * 1.2;
                    if (!b.isMain && !b.dragging) {
                        b.x -= nx * push;
                        b.vx *= -0.85;
                    }
                    if (!other.isMain && !other.dragging) {
                        other.x += nx * push;
                        other.vx *= -0.85;
                    }
                }
            });

            // è½¯æ–¥åŠ›ï¼šé è¿‘ logo åŒºï¼ˆé¡¶éƒ¨1/3ï¼‰æ—¶è½»æŽ¨å¼€
            const logoBottom = h * 0.35;
            if (b.y - b.r < logoBottom) {
                const distToLogo = logoBottom - (b.y - b.r);
                const softForce = distToLogo * 0.0005;
                if (!b.isMain && !b.dragging) {
                    b.vy += softForce;
                }
            }

            // å±å¹•è¾¹ç•Œï¼ˆé˜²è´´è¾¹ï¼‰
            const margin = 15;
            if (b.x < b.r + margin) { b.x = b.r + margin; b.vx *= -0.8; }
            if (b.x > w - b.r - margin) { b.x = w - b.r - margin; b.vx *= -0.8; }
            if (b.y < b.r + margin) { b.y = b.r + margin; b.vy *= -0.8; }
            if (b.y > h - b.r - margin) { b.y = h - b.r - margin; b.vy *= -0.8; }

            b.el.style.transform = `translate3d(${b.x - b.baseR}px, \( {b.y - b.baseR}px, 0) scale( \){scale})`;
            b.el.style.opacity = 0.85 + breath * 0.2;
        });
    }

    function render() {
        ctx.clearRect(0, 0, w, h);
        bubbles.forEach((b1, i) => {
            bubbles.slice(i + 1).forEach(b2 => {
                const dist = Math.hypot(b1.x - b2.x, b1.y - b2.y);
                if (dist > 550) return;
                ctx.beginPath();
                ctx.moveTo(b1.x, b1.y);
                for (let k = 1; k < 5; k++) {
                    const offset = (Math.sin(time * 3 + k) * 0.5 + 0.5) * 60;
                    ctx.lineTo(
                        b1.x + (b2.x - b1.x) * k / 5 + (Math.random() - 0.5) * offset,
                        b1.y + (b2.y - b1.y) * k / 5 + (Math.random() - 0.5) * offset
                    );
                }
                ctx.lineTo(b2.x, b2.y);
                ctx.strokeStyle = `rgba(255,255,255,${0.5 * (1 - dist/550) * (1.2 + Math.sin(time * 2))})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        });
        update();
        requestAnimationFrame(render);
    }

    // æ‹–æ‹½é€»è¾‘
    canvas.addEventListener('touchstart', e => {
        const touch = e.touches[0];
        touchStartTime = Date.now();
        dragTarget = null;
        bubbles.forEach(b => {
            const dx = touch.clientX - b.x;
            const dy = touch.clientY - b.y;
            if (Math.hypot(dx, dy) < b.r * 1.3) {
                dragTarget = b;
                if (!b.isMain) {
                    b.dragging = true;
                    dragOffset.x = touch.clientX - b.x;
                    dragOffset.y = touch.clientY - b.y;
                }
            }
        });
    });

    window.addEventListener('touchmove', e => {
        if (!dragTarget || dragTarget.isMain) return;
        e.preventDefault();
        const touch = e.touches[0];
        dragTarget.x = touch.clientX - dragOffset.x;
        dragTarget.y = touch.clientY - dragOffset.y;
    }, { passive: false });

    window.addEventListener('touchend', e => {
        if (!dragTarget) return;
        const duration = Date.now() - touchStartTime;
        const dist = Math.hypot(e.changedTouches[0].clientX - dragTarget.x, e.changedTouches[0].clientY - dragTarget.y);
        if (duration < 300 && Math.abs(dist) < 15) {
            window.location.href = dragTarget.url;
        }
        if (dragTarget && !dragTarget.isMain) dragTarget.dragging = false;
        dragTarget = null;
    });

    window.addEventListener('resize', init);
    init();
    render();
</script>
</body>
</html>
